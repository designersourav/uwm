{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport { derefLayers } from '@mapbox/mapbox-gl-style-spec';\nimport { expression, Color, function as fn, latest as spec, featureFilter as createFilter } from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport { deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing, createCanvas } from './util';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nvar expressionData = function expressionData(rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  }\n\n  return compiledExpression.value;\n};\n\nvar emptyObj = {};\nvar zoomObj = {\n  zoom: 0\n};\n/** @private */\n\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\n\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  var layerId = layer.id;\n\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n\n  var functions = functionCache[layerId];\n\n  if (!functions[property]) {\n    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n    var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n\n    if (value_1 === undefined) {\n      value_1 = propertySpec[\"default\"];\n    }\n\n    var isExpr = isExpression(value_1);\n\n    if (!isExpr && isFunction(value_1)) {\n      value_1 = convertFunction(value_1, propertySpec);\n      isExpr = true;\n    }\n\n    if (isExpr) {\n      var compiledExpression = expressionData(value_1, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value_1 = Color.parse(value_1);\n      }\n\n      functions[property] = function () {\n        return value_1;\n      };\n    }\n  }\n\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/** @private */\n\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\n\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\n\n\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n\n  return color;\n}\n\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\n\nfunction fromTemplate(text, properties) {\n  var parts;\n\n  do {\n    parts = text.match(templateRegEx);\n\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n\n  return text;\n}\n\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\n\nexport function recordStyleLayer(record) {\n  recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\n\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n  if (resolutions === void 0) {\n    resolutions = defaultResolutions;\n  }\n\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  var spriteImage, spriteImgSize;\n\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img_1 = new Image();\n      img_1.crossOrigin = 'anonymous';\n\n      img_1.onload = function () {\n        spriteImage = img_1;\n        spriteImgSize = [img_1.width, img_1.height];\n        olLayer.changed();\n        img_1.onload = null;\n      };\n\n      img_1.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker =\n      /** @type {*} */\n      self; // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n\n  var allLayers = derefLayers(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var mapboxSource;\n\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source_1 = glStyle.sources[mapboxSource];\n\n        if (!source_1) {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n        }\n\n        var type = source_1.type;\n\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n        }\n      }\n\n      var layers = layersBySourceLayer[sourceLayer];\n\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    } // TODO revisit when diffing gets added\n\n\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  var textHalo = new Stroke();\n  var textColor = new Fill();\n  var iconImageCache = {};\n  var patternCache = {};\n  var styles = [];\n\n  var styleFunction = function styleFunction(feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n\n    if (!layers) {\n      return;\n    }\n\n    var zoom = resolutions.indexOf(resolution);\n\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    var featureBelongsToLayer;\n\n    var _loop_1 = function _loop_1(i, ii) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj;\n      var paint = layer.paint || emptyObj;\n\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        return \"continue\";\n      }\n\n      var filter = layer.filter;\n\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        featureBelongsToLayer = layer;\n        var color = void 0,\n            opacity = void 0,\n            fill = void 0,\n            stroke = void 0,\n            strokeColor = void 0,\n            style = void 0;\n        var index = layerData.index;\n\n        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n\n          if (layer.type + '-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n\n            if (fillIcon) {\n              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n\n              if (spriteImage && spriteData && spriteData[icon_1]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new Style({\n                    fill: new Fill()\n                  });\n                }\n\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon_1 + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon_1];\n                  var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  var ctx =\n                  /** @type {CanvasRenderingContext2D} */\n                  canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n\n            if (color) {\n              if (layer.type + '-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n              }\n\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n\n              ++stylesLength;\n              style = styles[stylesLength];\n\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = styles[stylesLength] = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n              }\n\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) : undefined;\n          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n\n          if (color && width_1 > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = styles[stylesLength] = new Style({\n                stroke: new Stroke()\n              });\n            }\n\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width_1);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n              return x * width_1;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon = void 0,\n            iconImg = void 0,\n            skipLabel = void 0;\n\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n\n            if (spriteImage && spriteData && spriteData[icon]) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n\n              if (type == 2) {\n                var geom = feature.getGeometry(); // ol package and ol-debug.js only\n\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n\n                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                        var x1 = coordinates[i_1];\n                        var y1 = coordinates[i_1 + 1];\n                        var x2 = coordinates[i_1 + stride];\n                        var y2 = coordinates[i_1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (type !== 2 || styleGeom) {\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n\n                if (!iconColor || iconColor.a !== 0) {\n                  var icon_cache_key = icon + '.' + iconSize;\n\n                  if (iconColor !== null) {\n                    icon_cache_key += '.' + iconColor;\n                  }\n\n                  iconImg = iconImageCache[icon_cache_key];\n\n                  if (!iconImg) {\n                    var spriteImageData = spriteData[icon];\n\n                    if (iconColor !== null) {\n                      // cut out the sprite and color it\n                      var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                      var ctx =\n                      /** @type {CanvasRenderingContext2D} */\n                      canvas.getContext('2d');\n                      ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                      var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n                      for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                        var a = iconColor.a;\n\n                        if (a !== 0) {\n                          data.data[c] = iconColor.r * 255 / a;\n                          data.data[c + 1] = iconColor.g * 255 / a;\n                          data.data[c + 2] = iconColor.b * 255 / a;\n                        }\n\n                        data.data[c + 3] = a;\n                      }\n\n                      ctx.putImageData(data, 0, 0);\n                      iconImg = iconImageCache[icon_cache_key] = new Icon({\n                        img: canvas,\n                        imgSize: [canvas.width, canvas.height],\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                    } else {\n                      iconImg = iconImageCache[icon_cache_key] = new Icon({\n                        img: spriteImage,\n                        imgSize: spriteImgSize,\n                        size: [spriteImageData.width, spriteImageData.height],\n                        offset: [spriteImageData.x, spriteImageData.y],\n                        rotateWithView: iconRotationAlignment === 'map',\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                    }\n                  }\n                }\n\n                if (iconImg) {\n                  ++stylesLength;\n                  style = styles[stylesLength];\n\n                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                    style = styles[stylesLength] = new Style();\n                  }\n\n                  style.setGeometry(styleGeom);\n                  iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                  style.setImage(iconImg);\n                  text = style.getText();\n                  style.setText(undefined);\n                  style.setZIndex(index);\n                  hasImage = true;\n                  skipLabel = false;\n                }\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new Style();\n          }\n\n          var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n\n          if (!iconImg) {\n            iconImg = iconImageCache[cache_key] = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n          }\n\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        var label = void 0;\n\n        if ('text-field' in layout) {\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new Style();\n            }\n\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n\n          text = style.getText();\n          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          var textTransform = layout['text-transform'];\n\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n\n          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          var wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f); // Text offset has to take halo width and line height into account\n\n          var vOffset = 0;\n          var hOffset = 0;\n\n          if (placement == 'point') {\n            var textAlign = 'center';\n\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n\n          var textBaseline = 'middle';\n\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n\n          if (haloColor) {\n            textHalo.setColor(haloColor); // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n\n            textHaloWidth *= 2; // 1/4 of text size (spec) x 2\n\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          var padding = text.getPadding();\n\n          if (textPadding !== padding[0]) {\n            padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n          }\n\n          style.setZIndex(index);\n        }\n      }\n    };\n\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      _loop_1(i, ii);\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n\n      if (recordLayer) {\n        if (typeof feature.set === 'function') {\n          // ol/Feature\n          feature.set('mapbox-layer', featureBelongsToLayer);\n        } else {\n          // ol/render/Feature\n          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n        }\n      }\n\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };","map":{"version":3,"sources":["../src/stylefunction.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport { derefLayers } from '@mapbox/mapbox-gl-style-spec';\nimport { expression, Color, function as fn, latest as spec, featureFilter as createFilter } from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport { deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing, createCanvas } from './util';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n    'Point': 1,\n    'MultiPoint': 1,\n    'LineString': 2,\n    'MultiLineString': 2,\n    'Polygon': 3,\n    'MultiPolygon': 3\n};\nvar anchor = {\n    'center': [0.5, 0.5],\n    'left': [0, 0.5],\n    'right': [1, 0.5],\n    'top': [0.5, 0],\n    'bottom': [0.5, 1],\n    'top-left': [0, 0],\n    'top-right': [1, 0],\n    'bottom-left': [0, 1],\n    'bottom-right': [1, 1]\n};\nvar expressionData = function (rawExpression, propertySpec) {\n    var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n    if (compiledExpression.result === 'error') {\n        throw new Error(compiledExpression.value.map(function (err) { return err.key + \": \" + err.message; }).join(', '));\n    }\n    return compiledExpression.value;\n};\nvar emptyObj = {};\nvar zoomObj = { zoom: 0 };\n/** @private */\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n    var layerId = layer.id;\n    if (!functionCache[layerId]) {\n        functionCache[layerId] = {};\n    }\n    var functions = functionCache[layerId];\n    if (!functions[property]) {\n        var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n        var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n        if (value_1 === undefined) {\n            value_1 = propertySpec.default;\n        }\n        var isExpr = isExpression((value_1));\n        if (!isExpr && isFunction(value_1)) {\n            value_1 = convertFunction(value_1, propertySpec);\n            isExpr = true;\n        }\n        if (isExpr) {\n            var compiledExpression = expressionData(value_1, propertySpec);\n            functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n        }\n        else {\n            if (propertySpec.type == 'color') {\n                value_1 = Color.parse(value_1);\n            }\n            functions[property] = function () {\n                return value_1;\n            };\n        }\n    }\n    zoomObj.zoom = zoom;\n    return functions[property](zoomObj, feature);\n}\n/** @private */\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n    if (!(layerId in filterCache)) {\n        filterCache[layerId] = createFilter(filter).filter;\n    }\n    zoomObj.zoom = zoom;\n    return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n    if (color) {\n        if (color.a === 0 || opacity === 0) {\n            return undefined;\n        }\n        var a = color.a;\n        opacity = opacity === undefined ? 1 : opacity;\n        return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) +\n            ',' + Math.round(color.b * 255 / a) + ',' + (a * opacity) + ')';\n    }\n    return color;\n}\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n    var parts;\n    do {\n        parts = text.match(templateRegEx);\n        if (parts) {\n            var value = properties[parts[2]] || '';\n            text = parts[1] + value + parts[3];\n        }\n    } while (parts);\n    return text;\n}\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\nexport function recordStyleLayer(record) {\n    recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n    if (resolutions === void 0) { resolutions = defaultResolutions; }\n    if (typeof glStyle == 'string') {\n        glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n        throw new Error('glStyle version 8 required.');\n    }\n    var spriteImage, spriteImgSize;\n    if (spriteImageUrl) {\n        if (typeof Image !== 'undefined') {\n            var img_1 = new Image();\n            img_1.crossOrigin = 'anonymous';\n            img_1.onload = function () {\n                spriteImage = img_1;\n                spriteImgSize = [img_1.width, img_1.height];\n                olLayer.changed();\n                img_1.onload = null;\n            };\n            img_1.src = spriteImageUrl;\n        }\n        else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) { //eslint-disable-line\n            var worker = /** @type {*} */ (self);\n            // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n            worker.postMessage({\n                action: 'loadImage',\n                src: spriteImageUrl\n            });\n            worker.addEventListener('message', function handler(event) {\n                if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n                    spriteImage = event.data.image;\n                    spriteImgSize = [spriteImage.width, spriteImage.height];\n                }\n            });\n        }\n    }\n    var allLayers = derefLayers(glStyle.layers);\n    var layersBySourceLayer = {};\n    var mapboxLayers = [];\n    var mapboxSource;\n    for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n        var layer = allLayers[i];\n        var layerId = layer.id;\n        if (typeof source == 'string' && layer.source == source ||\n            source.indexOf(layerId) !== -1) {\n            var sourceLayer = layer['source-layer'];\n            if (!mapboxSource) {\n                mapboxSource = layer.source;\n                var source_1 = glStyle.sources[mapboxSource];\n                if (!source_1) {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n                }\n                var type = source_1.type;\n                if (type !== 'vector' && type !== 'geojson') {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n                }\n            }\n            var layers = layersBySourceLayer[sourceLayer];\n            if (!layers) {\n                layers = layersBySourceLayer[sourceLayer] = [];\n            }\n            layers.push({\n                layer: layer,\n                index: i\n            });\n            mapboxLayers.push(layerId);\n        }\n        // TODO revisit when diffing gets added\n        delete functionCache[layerId];\n        delete filterCache[layerId];\n    }\n    var textHalo = new Stroke();\n    var textColor = new Fill();\n    var iconImageCache = {};\n    var patternCache = {};\n    var styles = [];\n    var styleFunction = function (feature, resolution) {\n        var properties = feature.getProperties();\n        var layers = layersBySourceLayer[properties.layer];\n        if (!layers) {\n            return;\n        }\n        var zoom = resolutions.indexOf(resolution);\n        if (zoom == -1) {\n            zoom = getZoomForResolution(resolution, resolutions);\n        }\n        var type = types[feature.getGeometry().getType()];\n        var f = {\n            properties: properties,\n            type: type\n        };\n        var stylesLength = -1;\n        var featureBelongsToLayer;\n        var _loop_1 = function (i, ii) {\n            var layerData = layers[i];\n            var layer = layerData.layer;\n            var layerId = layer.id;\n            var layout = layer.layout || emptyObj;\n            var paint = layer.paint || emptyObj;\n            if (layout.visibility === 'none' || ('minzoom' in layer && zoom < layer.minzoom) ||\n                ('maxzoom' in layer && zoom >= layer.maxzoom)) {\n                return \"continue\";\n            }\n            var filter = layer.filter;\n            if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n                featureBelongsToLayer = layer;\n                var color = void 0, opacity = void 0, fill = void 0, stroke = void 0, strokeColor = void 0, style = void 0;\n                var index = layerData.index;\n                if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n                    opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n                    if (layer.type + '-pattern' in paint) {\n                        var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n                        if (fillIcon) {\n                            var icon_1 = typeof fillIcon === 'string'\n                                ? fromTemplate(fillIcon, properties)\n                                : fillIcon.toString();\n                            if (spriteImage && spriteData && spriteData[icon_1]) {\n                                ++stylesLength;\n                                style = styles[stylesLength];\n                                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                                    style = styles[stylesLength] = new Style({\n                                        fill: new Fill()\n                                    });\n                                }\n                                fill = style.getFill();\n                                style.setZIndex(index);\n                                var icon_cache_key = icon_1 + '.' + opacity;\n                                var pattern = patternCache[icon_cache_key];\n                                if (!pattern) {\n                                    var spriteImageData = spriteData[icon_1];\n                                    var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                    var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                    ctx.globalAlpha = opacity;\n                                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                    pattern = ctx.createPattern(canvas, 'repeat');\n                                    patternCache[icon_cache_key] = pattern;\n                                }\n                                fill.setColor(pattern);\n                            }\n                        }\n                    }\n                    else {\n                        color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n                        if (color) {\n                            if (layer.type + '-outline-color' in paint) {\n                                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n                            }\n                            if (!strokeColor) {\n                                strokeColor = color;\n                            }\n                            ++stylesLength;\n                            style = styles[stylesLength];\n                            if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                                style = styles[stylesLength] = new Style({\n                                    fill: new Fill(),\n                                    stroke: new Stroke()\n                                });\n                            }\n                            fill = style.getFill();\n                            fill.setColor(color);\n                            stroke = style.getStroke();\n                            stroke.setColor(strokeColor);\n                            stroke.setWidth(1);\n                            style.setZIndex(index);\n                        }\n                    }\n                }\n                if (type != 1 && layer.type == 'line') {\n                    color = !('line-pattern' in paint) && 'line-color' in paint ?\n                        colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) :\n                        undefined;\n                    var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n                    if (color && width_1 > 0) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n                            style = styles[stylesLength] = new Style({\n                                stroke: new Stroke()\n                            });\n                        }\n                        stroke = style.getStroke();\n                        stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n                        stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n                        stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n                        stroke.setColor(color);\n                        stroke.setWidth(width_1);\n                        stroke.setLineDash(paint['line-dasharray'] ?\n                            getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n                                return x * width_1;\n                            }) : null);\n                        style.setZIndex(index);\n                    }\n                }\n                var hasImage = false;\n                var text = null;\n                var placementAngle = 0;\n                var icon = void 0, iconImg = void 0, skipLabel = void 0;\n                if ((type == 1 || type == 2) && 'icon-image' in layout) {\n                    var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n                    if (iconImage) {\n                        icon = typeof iconImage === 'string'\n                            ? fromTemplate(iconImage, properties)\n                            : iconImage.toString();\n                        var styleGeom = undefined;\n                        if (spriteImage && spriteData && spriteData[icon]) {\n                            var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n                            if (type == 2) {\n                                var geom = feature.getGeometry();\n                                // ol package and ol-debug.js only\n                                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                                    var extent = geom.getExtent();\n                                    var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                                    if (size > 150) {\n                                        //FIXME Do not hard-code a size of 150\n                                        var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n                                        if (!renderFeature) {\n                                            renderFeatureCoordinates = [NaN, NaN];\n                                            renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                                        }\n                                        styleGeom = renderFeature;\n                                        renderFeatureCoordinates[0] = midpoint[0];\n                                        renderFeatureCoordinates[1] = midpoint[1];\n                                        var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                                        if (placement === 'line' && iconRotationAlignment === 'map') {\n                                            var stride = geom.getStride();\n                                            var coordinates = geom.getFlatCoordinates();\n                                            for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                                                var x1 = coordinates[i_1];\n                                                var y1 = coordinates[i_1 + 1];\n                                                var x2 = coordinates[i_1 + stride];\n                                                var y2 = coordinates[i_1 + stride + 1];\n                                                var minX = Math.min(x1, x2);\n                                                var minY = Math.min(y1, y2);\n                                                var maxX = Math.max(x1, x2);\n                                                var maxY = Math.max(y1, y2);\n                                                if (midpoint[0] >= minX && midpoint[0] <= maxX &&\n                                                    midpoint[1] >= minY && midpoint[1] <= maxY) {\n                                                    placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (type !== 2 || styleGeom) {\n                                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n                                if (!iconColor || iconColor.a !== 0) {\n                                    var icon_cache_key = icon + '.' + iconSize;\n                                    if (iconColor !== null) {\n                                        icon_cache_key += '.' + iconColor;\n                                    }\n                                    iconImg = iconImageCache[icon_cache_key];\n                                    if (!iconImg) {\n                                        var spriteImageData = spriteData[icon];\n                                        if (iconColor !== null) {\n                                            // cut out the sprite and color it\n                                            var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                            var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                            ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                            var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                                            for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                                                var a = iconColor.a;\n                                                if (a !== 0) {\n                                                    data.data[c] = iconColor.r * 255 / a;\n                                                    data.data[c + 1] = iconColor.g * 255 / a;\n                                                    data.data[c + 2] = iconColor.b * 255 / a;\n                                                }\n                                                data.data[c + 3] = a;\n                                            }\n                                            ctx.putImageData(data, 0, 0);\n                                            iconImg = iconImageCache[icon_cache_key] = new Icon({\n                                                img: canvas,\n                                                imgSize: [canvas.width, canvas.height],\n                                                scale: iconSize / spriteImageData.pixelRatio\n                                            });\n                                        }\n                                        else {\n                                            iconImg = iconImageCache[icon_cache_key] = new Icon({\n                                                img: spriteImage,\n                                                imgSize: spriteImgSize,\n                                                size: [spriteImageData.width, spriteImageData.height],\n                                                offset: [spriteImageData.x, spriteImageData.y],\n                                                rotateWithView: iconRotationAlignment === 'map',\n                                                scale: iconSize / spriteImageData.pixelRatio\n                                            });\n                                        }\n                                    }\n                                }\n                                if (iconImg) {\n                                    ++stylesLength;\n                                    style = styles[stylesLength];\n                                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                                        style = styles[stylesLength] = new Style();\n                                    }\n                                    style.setGeometry(styleGeom);\n                                    iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                                    iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                                    iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                                    style.setImage(iconImg);\n                                    text = style.getText();\n                                    style.setText(undefined);\n                                    style.setZIndex(index);\n                                    hasImage = true;\n                                    skipLabel = false;\n                                }\n                            }\n                            else {\n                                skipLabel = true;\n                            }\n                        }\n                    }\n                }\n                if (type == 1 && 'circle-radius' in paint) {\n                    ++stylesLength;\n                    style = styles[stylesLength];\n                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                        style = styles[stylesLength] = new Style();\n                    }\n                    var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n                    var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n                    var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n                    var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n                    var cache_key = circleRadius + '.' + circleStrokeColor + '.' +\n                        circleColor + '.' + circleStrokeWidth;\n                    iconImg = iconImageCache[cache_key];\n                    if (!iconImg) {\n                        iconImg = iconImageCache[cache_key] = new Circle({\n                            radius: circleRadius,\n                            stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                                width: circleStrokeWidth,\n                                color: circleStrokeColor\n                            }) : undefined,\n                            fill: circleColor ? new Fill({\n                                color: circleColor\n                            }) : undefined\n                        });\n                    }\n                    style.setImage(iconImg);\n                    text = style.getText();\n                    style.setText(undefined);\n                    style.setGeometry(undefined);\n                    style.setZIndex(index);\n                    hasImage = true;\n                }\n                var label = void 0;\n                if ('text-field' in layout) {\n                    var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n                    label = fromTemplate(textField, properties).trim();\n                    opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n                }\n                if (label && opacity && !skipLabel) {\n                    if (!hasImage) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n                            style = styles[stylesLength] = new Style();\n                        }\n                        style.setImage(undefined);\n                        style.setGeometry(undefined);\n                    }\n                    if (!style.getText()) {\n                        style.setText(text || new Text({\n                            padding: [2, 2, 2, 2]\n                        }));\n                    }\n                    text = style.getText();\n                    var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n                    var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n                    var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n                    var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n                    var textTransform = layout['text-transform'];\n                    if (textTransform == 'uppercase') {\n                        label = label.toUpperCase();\n                    }\n                    else if (textTransform == 'lowercase') {\n                        label = label.toLowerCase();\n                    }\n                    var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n                    var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n                    var wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n                    text.setText(wrappedLabel);\n                    text.setFont(font);\n                    text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n                    var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n                    var placement = (hasImage || type == 1) ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    text.setPlacement(placement);\n                    var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n                    var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n                    var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n                    // Text offset has to take halo width and line height into account\n                    var vOffset = 0;\n                    var hOffset = 0;\n                    if (placement == 'point') {\n                        var textAlign = 'center';\n                        if (textAnchor.indexOf('left') !== -1) {\n                            textAlign = 'left';\n                            hOffset = textHaloWidth;\n                        }\n                        else if (textAnchor.indexOf('right') !== -1) {\n                            textAlign = 'right';\n                            hOffset = -textHaloWidth;\n                        }\n                        text.setTextAlign(textAlign);\n                        var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n                        text.setRotateWithView(textRotationAlignment == 'map');\n                    }\n                    else {\n                        text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n                        text.setTextAlign();\n                        text.setRotateWithView(false);\n                    }\n                    var textBaseline = 'middle';\n                    if (textAnchor.indexOf('bottom') == 0) {\n                        textBaseline = 'bottom';\n                        vOffset = -textHaloWidth - (0.5 * (textLineHeight - 1)) * textSize;\n                    }\n                    else if (textAnchor.indexOf('top') == 0) {\n                        textBaseline = 'top';\n                        vOffset = textHaloWidth + (0.5 * (textLineHeight - 1)) * textSize;\n                    }\n                    text.setTextBaseline(textBaseline);\n                    text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n                    text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n                    textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n                    text.setFill(textColor);\n                    var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n                    if (haloColor) {\n                        textHalo.setColor(haloColor);\n                        // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n                        // Halo width must be doubled because it is applied around the center of the text outline\n                        textHaloWidth *= 2;\n                        // 1/4 of text size (spec) x 2\n                        var halfTextSize = 0.5 * textSize;\n                        textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n                        text.setStroke(textHalo);\n                    }\n                    else {\n                        text.setStroke(undefined);\n                    }\n                    var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n                    var padding = text.getPadding();\n                    if (textPadding !== padding[0]) {\n                        padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n                    }\n                    style.setZIndex(index);\n                }\n            }\n        };\n        for (var i = 0, ii = layers.length; i < ii; ++i) {\n            _loop_1(i, ii);\n        }\n        if (stylesLength > -1) {\n            styles.length = stylesLength + 1;\n            if (recordLayer) {\n                if (typeof feature.set === 'function') {\n                    // ol/Feature\n                    feature.set('mapbox-layer', featureBelongsToLayer);\n                }\n                else {\n                    // ol/render/Feature\n                    feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n                }\n            }\n            return styles;\n        }\n    };\n    olLayer.setStyle(styleFunction);\n    olLayer.set('mapbox-source', mapboxSource);\n    olLayer.set('mapbox-layers', mapboxLayers);\n    return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };\n//# sourceMappingURL=stylefunction.js.map"]},"metadata":{},"sourceType":"module"}